import { stringToBase64 } from 'uint8array-extras';

var T=Object.defineProperty;var b=(e,t,n)=>t in e?T(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var r=(e,t,n)=>(b(e,typeof t!="symbol"?t+"":t,n),n),d=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)};var h=(e,t,n)=>(d(e,t,"read from private field"),n?n.call(e):t.get(e)),g=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n);},f=(e,t,n,i)=>(d(e,t,"write to private field"),i?i.call(e,n):t.set(e,n),n);var k=e=>typeof e=="object"&&e!==null&&"type"in e&&e.type==="OAuth";var A={error(e){console.error("[ERROR]: ",e);},warn(e){console.warn("[WARN]: ",e);},info(e){console.info("[INFO]: ",e);},http(e){console.log("[HTTP]: ",e);},verbose(e){console.log("[LOG]: ",e);},debug(e){console.debug("[DEBUG]: ",e);},silly(e){console.log("[SILLY]: ",e);}};var x=e=>!!(e!==null&&e&&typeof e=="object"&&"message"in e||e instanceof Error),y=e=>x(e)?e:new Error("Unknown error");var a,p=class{constructor(t,n){g(this,a,null);r(this,"baseUrl");r(this,"apiPrefix");r(this,"customFetch");r(this,"authentication");r(this,"defaultLocale");r(this,"cache");r(this,"serializer");r(this,"logger");r(this,"debug");if(!t)throw new Error("baseUrl is required");let{apiPrefix:i,customFetch:s,authentication:o,cache:c,debug:u,defaultLocale:l,serializer:m,logger:w=A}=n||{};this.baseUrl=t,this.apiPrefix=i,this.customFetch=s,this.authentication=o,this.cache=c,this.defaultLocale=l,this.serializer=m,this.logger=w,this.debug=u;}async fetch(t,n){let i=n?.credentials==="omit";this.debug&&i&&this.log("verbose",`Disabling authentication for request to ${t}`);try{let s,o=i?n:await this.addAuthorizationHeader(n);return s=fetch,this.customFetch&&(s=this.customFetch),{response:await s(t,o),error:null}}catch(s){let o=y(s);return this.debug&&this.log("error",o.message),{response:null,error:o}}}async getAccessToken({clientId:t,clientSecret:n}){if(!t||!n||!k(this.authentication))throw new Error("credentials.clientId or credentials.clientSecret is missing on the authentication option.");let i={grant_type:"client_credentials",client_id:t,client_secret:n},s=`${this.baseUrl}/oauth/token`,o;o=fetch,this.customFetch&&(o=this.customFetch);let c=await o(s,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams(i).toString()});if(c.ok){let u=await c.json(),l={accessToken:u.access_token,validUntil:Date.now()+u.expires_in*1e3,tokenType:u.token_type};return f(this,a,l),l}throw new Error("Could not authenticate with the provided credentials.")}async addAuthorizationHeader(t){if(!this.authentication)return t||{};let n=new Headers(t?.headers);switch(this.authentication.type){case"Basic":{let i=stringToBase64(`${this.authentication?.credentials.username}:${this.authentication?.credentials.password}`);n.set("Authorization",`${this.authentication.type} ${i}`);break}case"OAuth":{let i=h(this,a)?.tokenType,s=h(this,a)?.accessToken,o=h(this,a)?.validUntil&&h(this,a).validUntil-10*1e3<Date.now();if(!i||!s||o){this.debug&&this.log("debug","OAuth token is missing or expired. Fetching a new one.");let c=await this.getAccessToken({clientId:this.authentication.credentials.clientId,clientSecret:this.authentication.credentials.clientSecret});i=c.tokenType,s=c.accessToken;}n.set("Authorization",`${i} ${s}`);break}case"Custom":n.set("Authorization",`${this.authentication.credentials.value}`);break;default:this.debug&&this.log("debug","No valid authentication type is configured. Skipping authorization header.");}return {...t,headers:n}}log(t,n){this.logger&&this.logger[t]&&typeof this.logger[t]=="function"&&this.logger[t]?.(n);}async getCachedResponse(t){if(!this.cache)return null;this.debug&&this.log("verbose",`Checking cache for key ${t}...`);let n=await this.cache.get(t);return n?(this.debug&&this.log("verbose",`Found cached response for key ${t}...`),n):(this.debug&&this.log("verbose",`No cached response found for key ${t}...`),null)}};a=new WeakMap;

export { p as ApiClient, k as isOAuth };
