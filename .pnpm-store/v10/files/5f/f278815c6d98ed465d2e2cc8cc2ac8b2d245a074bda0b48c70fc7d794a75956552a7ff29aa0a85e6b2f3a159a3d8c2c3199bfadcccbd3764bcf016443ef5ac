import { stringToBase64 } from 'uint8array-extras';

var b=Object.defineProperty;var O=(e,t,n)=>t in e?b(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var r=(e,t,n)=>(O(e,typeof t!="symbol"?t+"":t,n),n),A=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)};var l=(e,t,n)=>(A(e,t,"read from private field"),t.get(e)),k=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n);},m=(e,t,n,i)=>(A(e,t,"write to private field"),t.set(e,n),n);var g=e=>typeof e=="object"&&e!==null&&"type"in e&&e.type==="OAuth";var w={error(e){console.error("[ERROR]: ",e);},warn(e){console.warn("[WARN]: ",e);},info(e){console.info("[INFO]: ",e);},http(e){console.log("[HTTP]: ",e);},verbose(e){console.log("[LOG]: ",e);},debug(e){console.debug("[DEBUG]: ",e);},silly(e){console.log("[SILLY]: ",e);}};var x=e=>!!(e!==null&&e&&typeof e=="object"&&"message"in e||e instanceof Error),T=e=>x(e)?e:new Error("Unknown error");var c,f=class{constructor(t,n){k(this,c,null);r(this,"baseUrl");r(this,"apiPrefix");r(this,"customFetch");r(this,"authentication");r(this,"defaultLocale");r(this,"cache");r(this,"serializer");r(this,"logger");r(this,"debug");if(!t)throw new Error("baseUrl is required");let{apiPrefix:i,customFetch:s,authentication:o,cache:a,debug:d,defaultLocale:h,serializer:p,logger:u=w}=n||{};this.baseUrl=t,this.apiPrefix=i,this.customFetch=s,this.authentication=o,this.cache=a,this.defaultLocale=h,this.serializer=p,this.logger=u,this.debug=d;}async fetch(t,n){let i=n?.credentials==="omit";this.debug&&i&&this.log("verbose",`Disabling authentication for request to ${t}`);try{let s,o=i?n:await this.addAuthorizationHeader(n);return s=fetch,this.customFetch&&(s=this.customFetch),{response:await s(t,o),error:null}}catch(s){let o=T(s);return this.debug&&this.log("error",o.message),{response:null,error:o}}}async getAccessToken({grantType:t="client_credentials",clientId:n,clientSecret:i,username:s,password:o}){if(!n||!i||!g(this.authentication))throw new Error("credentials.clientId or credentials.clientSecret is missing on the authentication option.");let a;if(t==="password"){if(!s||!o||!g(this.authentication))throw new Error("credentials.username or credentials.password is missing on the authentication option.");a={grant_type:"password",client_id:n,client_secret:i,username:s,password:o};}else a={grant_type:"client_credentials",client_id:n,client_secret:i};let d=`${this.baseUrl}/oauth/token`,h;h=fetch,this.customFetch&&(h=this.customFetch);let p=await h(d,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams(a).toString()});if(p.ok){let u=await p.json(),y={accessToken:u.access_token,validUntil:Date.now()+u.expires_in*1e3,tokenType:u.token_type};return m(this,c,y),y}throw new Error("Could not authenticate with the provided credentials.")}async addAuthorizationHeader(t){if(!this.authentication)return t||{};let n=new Headers(t?.headers);switch(this.authentication.type){case"Basic":{let i=stringToBase64(`${this.authentication?.credentials.username}:${this.authentication?.credentials.password}`);n.set("Authorization",`${this.authentication.type} ${i}`);break}case"OAuth":{let i=l(this,c)?.tokenType,s=l(this,c)?.accessToken,o=l(this,c)?.validUntil&&l(this,c).validUntil-10*1e3<Date.now();if(!i||!s||o){this.debug&&this.log("debug","OAuth token is missing or expired. Fetching a new one.");let a=await this.getAccessToken({grantType:this.authentication.credentials.grantType,clientId:this.authentication.credentials.clientId,clientSecret:this.authentication.credentials.clientSecret,username:this.authentication.credentials.username,password:this.authentication.credentials.password});i=a.tokenType,s=a.accessToken;}n.set("Authorization",`${i} ${s}`);break}case"Custom":n.set("Authorization",`${this.authentication.credentials.value}`);break;default:this.debug&&this.log("debug","No valid authentication type is configured. Skipping authorization header.");}return {...t,headers:n}}log(t,n){this.logger&&this.logger[t]&&typeof this.logger[t]=="function"&&this.logger[t]?.(n);}async getCachedResponse(t){if(!this.cache)return null;this.debug&&this.log("verbose",`Checking cache for key ${t}...`);let n=await this.cache.get(t);return n?(this.debug&&this.log("verbose",`Found cached response for key ${t}...`),n):(this.debug&&this.log("verbose",`No cached response found for key ${t}...`),null)}};c=new WeakMap;

export { f as ApiClient, g as isOAuth };
